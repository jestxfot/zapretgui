# ui/pages/zapret2/user_presets_page.py
"""Zapret 2 Direct: user presets management."""

from __future__ import annotations

from datetime import datetime
import re
import webbrowser
from pathlib import Path
from typing import Optional

from PyQt6.QtCore import (
    Qt,
    pyqtSignal,
    QSize,
    QTimer,
    QFileSystemWatcher,
    QAbstractListModel,
    QModelIndex,
    QRect,
    QEvent,
    QPoint,
)
from PyQt6.QtGui import QColor, QPainter, QFontMetrics, QMouseEvent, QHelpEvent, QTransform
from PyQt6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QPushButton,
    QLineEdit,
    QFileDialog,
    QListView,
    QStyledItemDelegate,
    QStyleOptionViewItem,
    QStyle,
    QToolTip,
    QSizePolicy,
    QApplication,
    QFrame,
)
import qtawesome as qta

from ui.pages.base_page import BasePage
from ui.compat_widgets import ActionButton, PrimaryActionButton, SettingsCard, LineEdit, set_tooltip

try:
    from qfluentwidgets import (
        BodyLabel, CaptionLabel, StrongBodyLabel, SubtitleLabel,
        PushButton as FluentPushButton, PrimaryPushButton, ToolButton, PrimaryToolButton,
        MessageBox, InfoBar, MessageBoxBase, TransparentToolButton, TransparentPushButton, FluentIcon,
    )
    _HAS_FLUENT_LABELS = True
except ImportError:
    BodyLabel = QLabel
    CaptionLabel = QLabel
    StrongBodyLabel = QLabel
    SubtitleLabel = QLabel
    FluentPushButton = QPushButton
    PrimaryPushButton = QPushButton
    ToolButton = QPushButton
    PrimaryToolButton = QPushButton
    TransparentPushButton = QPushButton
    MessageBox = None
    InfoBar = None
    MessageBoxBase = object
    TransparentToolButton = None
    FluentIcon = None
    _HAS_FLUENT_LABELS = False


from ui.theme import get_theme_tokens
from ui.theme_semantic import get_semantic_palette
from log import log


_icon_cache: dict[str, object] = {}
_DEFAULT_PRESET_ICON_COLOR = "#5caee8"
_HEX_COLOR_RGB_RE = re.compile(r"^#(?:[0-9a-fA-F]{6})$")
_HEX_COLOR_RGBA_RE = re.compile(r"^#(?:[0-9a-fA-F]{8})$")
_CSS_RGBA_COLOR_RE = re.compile(
    r"^\s*rgba?\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*(?:,\s*([0-9]*\.?[0-9]+)\s*)?\)\s*$",
    re.IGNORECASE,
)


def _accent_fg_for_tokens(tokens) -> str:
    """Chooses readable foreground for the current accent color."""
    try:
        return str(tokens.accent_fg)
    except Exception:
        return "rgba(18, 18, 18, 0.90)"


def _normalize_preset_icon_color(value: Optional[str]) -> str:
    raw = str(value or "").strip()
    if _HEX_COLOR_RGB_RE.fullmatch(raw):
        return raw.lower()
    if _HEX_COLOR_RGBA_RE.fullmatch(raw):
        lowered = raw.lower()
        return f"#{lowered[1:7]}"
    try:
        return get_theme_tokens().accent_hex
    except Exception:
        return _DEFAULT_PRESET_ICON_COLOR


def _cached_icon(name: str, color: str):
    key = f"{name}|{color}"
    icon = _icon_cache.get(key)
    if icon is None:
        icon = qta.icon(name, color=color)
        _icon_cache[key] = icon
    return icon


def _relative_luminance(color: QColor) -> float:
    def _channel_luma(channel: int) -> float:
        value = max(0.0, min(1.0, float(channel) / 255.0))
        if value <= 0.03928:
            return value / 12.92
        return ((value + 0.055) / 1.055) ** 2.4

    return (
        0.2126 * _channel_luma(color.red())
        + 0.7152 * _channel_luma(color.green())
        + 0.0722 * _channel_luma(color.blue())
    )


def _contrast_ratio(foreground: QColor, background: QColor) -> float:
    fg = QColor(foreground)
    bg = QColor(background)
    fg.setAlpha(255)
    bg.setAlpha(255)
    l1 = _relative_luminance(fg)
    l2 = _relative_luminance(bg)
    lighter = max(l1, l2)
    darker = min(l1, l2)
    return (lighter + 0.05) / (darker + 0.05)


def _pick_contrast_color(
    preferred_color: str,
    background_color: QColor,
    fallback_colors: list[str],
    *,
    minimum_ratio: float = 2.4,
) -> str:
    bg = QColor(background_color)
    if not bg.isValid():
        bg = QColor("#000000")
    bg.setAlpha(255)

    candidates: list[str] = []
    for raw in [preferred_color, *fallback_colors]:
        value = str(raw or "").strip()
        if value and value not in candidates:
            candidates.append(value)

    best_color = None
    best_ratio = -1.0
    for candidate in candidates:
        color = QColor(candidate)
        if not color.isValid():
            continue
        color.setAlpha(255)
        ratio = _contrast_ratio(color, bg)
        if ratio >= minimum_ratio:
            return color.name(QColor.NameFormat.HexRgb)
        if ratio > best_ratio:
            best_ratio = ratio
            best_color = color

    if best_color is not None:
        return best_color.name(QColor.NameFormat.HexRgb)
    return "#f5f5f5" if _relative_luminance(bg) < 0.45 else "#111111"


def _color_with_alpha(color_value: str, alpha: int, fallback_hex: str) -> str:
    color = QColor(color_value)
    if not color.isValid():
        color = QColor(fallback_hex)
    color.setAlpha(max(0, min(255, int(alpha))))
    return f"rgba({color.red()}, {color.green()}, {color.blue()}, {color.alpha()})"


def _to_qcolor(value, fallback_hex: str = "#000000") -> QColor:
    if isinstance(value, QColor):
        color = QColor(value)
        if color.isValid():
            return color

    text = str(value or "").strip()
    if text:
        match = _CSS_RGBA_COLOR_RE.fullmatch(text)
        if match:
            try:
                r = max(0, min(255, int(match.group(1))))
                g = max(0, min(255, int(match.group(2))))
                b = max(0, min(255, int(match.group(3))))
                alpha_raw = match.group(4)

                if alpha_raw is None:
                    a = 255
                else:
                    a_float = float(alpha_raw)
                    if a_float <= 1.0:
                        a = int(round(max(0.0, min(1.0, a_float)) * 255.0))
                    else:
                        a = int(round(max(0.0, min(255.0, a_float))))

                return QColor(r, g, b, a)
            except Exception:
                pass

        color = QColor(text)
        if color.isValid():
            return color

    fallback = QColor(fallback_hex)
    if fallback.isValid():
        return fallback
    return QColor(0, 0, 0)


class _PresetListModel(QAbstractListModel):
    KindRole = Qt.ItemDataRole.UserRole + 1
    NameRole = Qt.ItemDataRole.UserRole + 2
    DescriptionRole = Qt.ItemDataRole.UserRole + 3
    DateRole = Qt.ItemDataRole.UserRole + 4
    ActiveRole = Qt.ItemDataRole.UserRole + 5
    TextRole = Qt.ItemDataRole.UserRole + 6
    IconColorRole = Qt.ItemDataRole.UserRole + 7

    def __init__(self, parent=None):
        super().__init__(parent)
        self._rows: list[dict[str, object]] = []

    def set_rows(self, rows: list[dict[str, object]]) -> None:
        self.beginResetModel()
        self._rows = rows
        self.endResetModel()

    def rowCount(self, parent: QModelIndex = QModelIndex()) -> int:
        if parent.isValid():
            return 0
        return len(self._rows)

    def data(self, index: QModelIndex, role: int = int(Qt.ItemDataRole.DisplayRole)):
        if not index.isValid() or index.row() < 0 or index.row() >= len(self._rows):
            return None

        row = self._rows[index.row()]
        kind = row.get("kind", "preset")

        if role == int(Qt.ItemDataRole.DisplayRole):
            if kind == "preset":
                return row.get("name", "")
            return row.get("text", "")

        if role == self.KindRole:
            return kind
        if role == self.NameRole:
            return row.get("name", "")
        if role == self.DescriptionRole:
            return row.get("description", "")
        if role == self.DateRole:
            return row.get("date", "")
        if role == self.ActiveRole:
            return bool(row.get("is_active", False))
        if role == self.TextRole:
            return row.get("text", "")
        if role == self.IconColorRole:
            return row.get("icon_color", _DEFAULT_PRESET_ICON_COLOR)

        return None


class _LinkedWheelListView(QListView):
    def wheelEvent(self, e):
        scrollbar = self.verticalScrollBar()
        if scrollbar is None:
            super().wheelEvent(e)
            return

        delta = e.angleDelta().y()
        at_top = scrollbar.value() <= scrollbar.minimum()
        at_bottom = scrollbar.value() >= scrollbar.maximum()

        if (delta > 0 and at_top) or (delta < 0 and at_bottom):
            # Let parent scroll area handle wheel at boundaries.
            e.ignore()
            return

        super().wheelEvent(e)
        e.accept()


class _PresetListDelegate(QStyledItemDelegate):
    action_triggered = pyqtSignal(str, str)

    _ROW_HEIGHT = 44
    _SECTION_HEIGHT = 24
    _EMPTY_HEIGHT = 64
    _ACTION_SIZE = 28
    _ACTION_SPACING = 6

    _ACTION_ICONS = {
        "rename": "fa5s.edit",
        "duplicate": "fa5s.copy",
        "reset": "fa5s.broom",
        "delete": "fa5s.trash",
        "export": "fa5s.file-export",
    }

    _ACTION_TOOLTIPS = {
        "rename": "Переименовать",
        "duplicate": "Дублировать",
        "reset": "Сбросить",
        "delete": "Удалить",
        "export": "Экспорт",
    }

    _PENDING_SHAKE_ROTATIONS = (0, -8, 8, -6, 6, -4, 4, -2, 0)
    _PENDING_SHAKE_INTERVAL_MS = 50

    def __init__(self, view: QListView):
        super().__init__(view)
        self._view = view
        self._pending_destructive: Optional[tuple[str, str]] = None
        self._pending_timer = QTimer(self)
        self._pending_timer.setSingleShot(True)
        self._pending_timer.timeout.connect(self._clear_pending_destructive)
        self._pending_shake_step = 0
        self._pending_shake_rotation = 0
        self._pending_shake_timer = QTimer(self)
        self._pending_shake_timer.timeout.connect(self._advance_pending_shake)

    def reset_interaction_state(self):
        self._clear_pending_destructive(update=False)

    def sizeHint(self, option: QStyleOptionViewItem, index: QModelIndex) -> QSize:
        kind = index.data(_PresetListModel.KindRole)
        if kind == "section":
            return QSize(0, self._SECTION_HEIGHT)
        if kind == "empty":
            return QSize(0, self._EMPTY_HEIGHT)
        return QSize(0, self._ROW_HEIGHT)

    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index: QModelIndex):
        kind = index.data(_PresetListModel.KindRole)

        if kind == "section":
            self._paint_section_row(painter, option, str(index.data(_PresetListModel.TextRole) or ""))
            return

        if kind == "empty":
            self._paint_empty_row(painter, option, str(index.data(_PresetListModel.TextRole) or ""))
            return

        self._paint_preset_row(painter, option, index)

    def editorEvent(self, event, model, option: QStyleOptionViewItem, index: QModelIndex):
        _ = model
        if index.data(_PresetListModel.KindRole) != "preset":
            return False
        if event.type() != QEvent.Type.MouseButtonRelease:
            return False
        if not isinstance(event, QMouseEvent):
            return False
        if event.button() != Qt.MouseButton.LeftButton:
            return False

        name = str(index.data(_PresetListModel.NameRole) or "")
        if not name:
            return False

        is_active = bool(index.data(_PresetListModel.ActiveRole))
        action = self._action_at(option.rect, is_active, event.position().toPoint())

        if action:
            self._handle_action_click(name, action, event)
            return True

        if not is_active:
            self._clear_pending_destructive(update=False)
            self.action_triggered.emit("activate", name)
            return True

        self._clear_pending_destructive(update=False)
        return False

    def helpEvent(self, event: QHelpEvent, view, option: QStyleOptionViewItem, index: QModelIndex) -> bool:
        if index.data(_PresetListModel.KindRole) != "preset":
            return super().helpEvent(event, view, option, index)

        name = str(index.data(_PresetListModel.NameRole) or "")
        is_active = bool(index.data(_PresetListModel.ActiveRole))
        action = self._action_at(option.rect, is_active, event.pos())
        if not action:
            return super().helpEvent(event, view, option, index)

        tooltip = self._ACTION_TOOLTIPS.get(action, "")
        if action in {"reset", "delete"} and self._pending_destructive == (name, action):
            tooltip = f"{tooltip}\nНажмите ещё раз для подтверждения"
        if tooltip:
            QToolTip.showText(event.globalPos(), tooltip, view)
            return True
        return super().helpEvent(event, view, option, index)

    def _handle_action_click(self, name: str, action: str, event: QMouseEvent):
        if action in {"reset", "delete"}:
            key = (name, action)
            if self._pending_destructive == key:
                self._clear_pending_destructive(update=False)
                self.action_triggered.emit(action, name)
                self._view.viewport().update()
                return

            self._pending_destructive = key
            self._start_pending_shake()
            self._pending_timer.start(3000)
            QToolTip.showText(event.globalPosition().toPoint(), "Нажмите ещё раз для подтверждения", self._view)
            self._view.viewport().update()
            return

        self._clear_pending_destructive(update=False)
        self.action_triggered.emit(action, name)
        self._view.viewport().update()

    def _clear_pending_destructive(self, update: bool = True):
        self._pending_timer.stop()
        self._pending_shake_timer.stop()
        self._pending_shake_step = 0
        self._pending_shake_rotation = 0
        if self._pending_destructive is None:
            return
        self._pending_destructive = None
        if update:
            self._view.viewport().update()

    def _start_pending_shake(self):
        self._pending_shake_timer.stop()
        self._pending_shake_step = 0
        self._pending_shake_rotation = int(self._PENDING_SHAKE_ROTATIONS[0])
        self._pending_shake_timer.start(self._PENDING_SHAKE_INTERVAL_MS)

    def _advance_pending_shake(self):
        self._pending_shake_step += 1
        if self._pending_shake_step >= len(self._PENDING_SHAKE_ROTATIONS):
            self._pending_shake_timer.stop()
            self._pending_shake_step = 0
            self._pending_shake_rotation = 0
            self._view.viewport().update()
            return

        self._pending_shake_rotation = int(self._PENDING_SHAKE_ROTATIONS[self._pending_shake_step])
        self._view.viewport().update()

    def _visible_actions(self, is_active: bool) -> list[str]:
        actions = ["rename", "duplicate", "reset"]
        if not is_active:
            actions.append("delete")
        actions.append("export")
        return actions

    def _action_rects(self, row_rect: QRect, is_active: bool) -> list[tuple[str, QRect]]:
        actions = self._visible_actions(is_active)
        if not actions:
            return []

        total_width = len(actions) * self._ACTION_SIZE + (len(actions) - 1) * self._ACTION_SPACING
        x = row_rect.right() - 12 - total_width + 1
        y = row_rect.center().y() - (self._ACTION_SIZE // 2)

        rects: list[tuple[str, QRect]] = []
        for action in actions:
            rects.append((action, QRect(x, y, self._ACTION_SIZE, self._ACTION_SIZE)))
            x += self._ACTION_SIZE + self._ACTION_SPACING
        return rects

    def _action_at(self, option_rect: QRect, is_active: bool, pos) -> Optional[str]:
        for action, rect in self._action_rects(option_rect, is_active):
            if rect.contains(pos):
                return action
        return None

    def _paint_action_icon(self, painter: QPainter, icon_name: str, icon_color: str, icon_rect: QRect, rotation: int = 0):
        icon = _cached_icon(icon_name, icon_color)
        pixmap = icon.pixmap(icon_rect.size())
        if pixmap.isNull():
            return

        if rotation:
            rotated = pixmap.transformed(QTransform().rotate(rotation), Qt.TransformationMode.SmoothTransformation)
            center = icon_rect.center()
            draw_x = center.x() - (rotated.width() // 2)
            draw_y = center.y() - (rotated.height() // 2)
            painter.drawPixmap(draw_x, draw_y, rotated)
            return

        painter.drawPixmap(icon_rect.topLeft(), pixmap)

    def _paint_section_row(self, painter: QPainter, option: QStyleOptionViewItem, text: str):
        painter.save()
        tokens = get_theme_tokens()
        rect = option.rect

        text_rect = rect.adjusted(12, 0, -12, 0)
        font = painter.font()
        font.setPointSize(9)
        font.setBold(True)
        painter.setFont(font)

        metrics = QFontMetrics(font)
        text_width = metrics.horizontalAdvance(text)

        painter.setPen(_to_qcolor(tokens.fg_muted, "#9aa2af"))
        painter.drawText(text_rect, int(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter), text)

        # Draw a subtle separator line to the right of the label.
        line_x1 = text_rect.left() + text_width + 10
        line_x2 = rect.right() - 12
        if line_x2 > line_x1:
            painter.setPen(_to_qcolor(tokens.divider, "#5f6368"))
            y = rect.center().y()
            painter.drawLine(line_x1, y, line_x2, y)
        painter.restore()

    def _paint_empty_row(self, painter: QPainter, option: QStyleOptionViewItem, text: str):
        painter.save()
        tokens = get_theme_tokens()
        painter.setPen(_to_qcolor(tokens.fg_muted, "#9aa2af"))
        font = painter.font()
        font.setPointSize(10)
        painter.setFont(font)
        painter.drawText(option.rect.adjusted(8, 0, -8, 0), int(Qt.AlignmentFlag.AlignCenter), text)
        painter.restore()

    def _paint_preset_row(self, painter: QPainter, option: QStyleOptionViewItem, index: QModelIndex):
        tokens = get_theme_tokens()
        semantic = get_semantic_palette(tokens.theme_name)
        name = str(index.data(_PresetListModel.NameRole) or "")
        date_text = str(index.data(_PresetListModel.DateRole) or "")
        is_active = bool(index.data(_PresetListModel.ActiveRole))

        row_rect = option.rect
        hovered = bool(option.state & QStyle.StateFlag.State_MouseOver)

        if is_active:
            bg = _to_qcolor(tokens.accent_soft_bg, tokens.accent_hex)
        elif hovered:
            bg = _to_qcolor(tokens.surface_bg_hover, tokens.surface_bg)
        else:
            bg = QColor(Qt.GlobalColor.transparent)

        painter.save()
        painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
        if bg.alpha() > 0:
            painter.fillRect(row_rect, bg)

        icon_rect = QRect(row_rect.left() + 12, row_rect.center().y() - 10, 20, 20)
        icon_name = "fa5s.star" if is_active else "fa5s.file-alt"
        icon_color = _pick_contrast_color(
            _normalize_preset_icon_color(str(index.data(_PresetListModel.IconColorRole) or "")),
            bg,
            [tokens.accent_hex, tokens.fg],
            minimum_ratio=2.6,
        )
        _cached_icon(icon_name, icon_color).paint(painter, icon_rect)

        action_rects = self._action_rects(row_rect, is_active)
        right_cursor = action_rects[0][1].left() - 10 if action_rects else row_rect.right() - 12

        if is_active:
            badge_text = "Активен"
            badge_font = painter.font()
            badge_font.setPointSize(8)
            badge_font.setBold(True)
            badge_metrics = QFontMetrics(badge_font)
            badge_width = badge_metrics.horizontalAdvance(badge_text) + 14
            badge_rect = QRect(right_cursor - badge_width, row_rect.center().y() - 9, badge_width, 18)

            painter.setBrush(QColor(tokens.accent_hex))
            painter.setPen(Qt.PenStyle.NoPen)
            painter.drawRoundedRect(badge_rect, 4, 4)

            painter.setFont(badge_font)
            painter.setPen(_to_qcolor(_accent_fg_for_tokens(tokens), "#f5f5f5"))
            painter.drawText(badge_rect, int(Qt.AlignmentFlag.AlignCenter), badge_text)
            right_cursor = badge_rect.left() - 10

        if date_text:
            date_font = painter.font()
            date_font.setPointSize(9)
            date_font.setBold(False)
            painter.setFont(date_font)
            date_metrics = QFontMetrics(date_font)
            date_width = date_metrics.horizontalAdvance(date_text)
            date_rect = QRect(max(row_rect.left() + 80, right_cursor - date_width), row_rect.top(), date_width, row_rect.height())
            painter.setPen(_to_qcolor(tokens.fg_faint, "#aeb5c1"))
            painter.drawText(date_rect, int(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter), date_text)
            right_cursor = date_rect.left() - 10

        name_left = icon_rect.right() + 10
        name_rect = QRect(name_left, row_rect.top(), max(40, right_cursor - name_left), row_rect.height())
        name_font = painter.font()
        name_font.setPointSize(10)
        name_font.setBold(True)
        painter.setFont(name_font)
        painter.setPen(_to_qcolor(tokens.fg, "#f5f5f5"))
        name_metrics = QFontMetrics(name_font)
        elided_name = name_metrics.elidedText(name, Qt.TextElideMode.ElideRight, name_rect.width())
        painter.drawText(name_rect, int(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter), elided_name)

        for action, action_rect in action_rects:
            pending = self._pending_destructive == (name, action)
            if pending:
                btn_bg = _to_qcolor(semantic.error_soft_bg, semantic.error)
                icon_col = _pick_contrast_color(
                    semantic.error,
                    btn_bg,
                    [semantic.on_color, tokens.fg],
                    minimum_ratio=2.8,
                )
            else:
                btn_bg = _to_qcolor(tokens.surface_bg_hover, tokens.surface_bg)
                icon_col = _pick_contrast_color(
                    str(tokens.fg_muted),
                    btn_bg,
                    [tokens.fg],
                    minimum_ratio=2.6,
                )

            painter.setBrush(btn_bg)
            painter.setPen(Qt.PenStyle.NoPen)
            painter.drawRoundedRect(action_rect, 6, 6)

            icon_name = self._ACTION_ICONS.get(action, "fa5s.circle")
            icon_rotation = self._pending_shake_rotation if pending else 0
            self._paint_action_icon(
                painter,
                icon_name,
                icon_col,
                action_rect.adjusted(7, 7, -7, -7),
                icon_rotation,
            )

        painter.restore()


class _CreatePresetDialog(MessageBoxBase):
    """Диалог создания нового пресета."""

    def __init__(self, existing_names: list, parent=None):
        if parent and not parent.isWindow():
            parent = parent.window()
        super().__init__(parent)
        self._existing_names = list(existing_names)
        self._source = "current"

        self.titleLabel = SubtitleLabel("Новый пресет", self.widget)
        self.subtitleLabel = BodyLabel(
            "Сохраните текущие настройки как отдельный пресет, "
            "чтобы быстро переключаться между конфигурациями.",
            self.widget,
        )
        self.subtitleLabel.setWordWrap(True)

        name_label = BodyLabel("Название", self.widget)
        self.nameEdit = LineEdit(self.widget)
        self.nameEdit.setPlaceholderText("Например: Игры / YouTube / Дом")
        self.nameEdit.setClearButtonEnabled(True)

        source_row = QHBoxLayout()
        source_label = BodyLabel("Создать на основе", self.widget)
        source_row.addWidget(source_label)
        source_row.addStretch()
        try:
            from qfluentwidgets import SegmentedWidget
            self._source_seg = SegmentedWidget(self.widget)
            self._source_seg.addItem("current", "Текущего активного")
            self._source_seg.addItem("empty", "Пустого")
            self._source_seg.setCurrentItem("current")
            self._source_seg.currentItemChanged.connect(lambda k: setattr(self, "_source", k))
            source_row.addWidget(self._source_seg)
        except Exception:
            pass

        self.warningLabel = CaptionLabel("", self.widget)
        try:
            from PyQt6.QtGui import QColor
            self.warningLabel.setTextColor("#cf1010", QColor(255, 28, 32))
        except Exception:
            self.warningLabel.setStyleSheet("color: #cf1010;")
        self.warningLabel.hide()

        self.viewLayout.addWidget(self.titleLabel)
        self.viewLayout.addWidget(self.subtitleLabel)
        self.viewLayout.addWidget(name_label)
        self.viewLayout.addWidget(self.nameEdit)
        self.viewLayout.addLayout(source_row)
        self.viewLayout.addWidget(self.warningLabel)

        self.yesButton.setText("Создать")
        self.cancelButton.setText("Отмена")
        self.widget.setMinimumWidth(420)

    def validate(self) -> bool:
        name = self.nameEdit.text().strip()
        if not name:
            self.warningLabel.setText("Введите название.")
            self.warningLabel.show()
            return False
        if name in self._existing_names:
            self.warningLabel.setText(f"Пресет «{name}» уже существует.")
            self.warningLabel.show()
            return False
        self.warningLabel.hide()
        return True


class _RenamePresetDialog(MessageBoxBase):
    """Диалог переименования пресета."""

    def __init__(self, current_name: str, existing_names: list, parent=None):
        if parent and not parent.isWindow():
            parent = parent.window()
        super().__init__(parent)
        self._current_name = str(current_name or "")
        self._existing_names = [n for n in existing_names if n != self._current_name]

        self.titleLabel = SubtitleLabel("Переименовать", self.widget)
        self.subtitleLabel = BodyLabel(
            "Имя пресета отображается в списке и используется для переключения.",
            self.widget,
        )
        self.subtitleLabel.setWordWrap(True)

        from_label = CaptionLabel(f"Текущее имя: {self._current_name}", self.widget)
        name_label = BodyLabel("Новое имя", self.widget)
        self.nameEdit = LineEdit(self.widget)
        self.nameEdit.setText(self._current_name)
        self.nameEdit.setPlaceholderText("Новое имя...")
        self.nameEdit.selectAll()
        self.nameEdit.setClearButtonEnabled(True)

        self.warningLabel = CaptionLabel("", self.widget)
        try:
            from PyQt6.QtGui import QColor
            self.warningLabel.setTextColor("#cf1010", QColor(255, 28, 32))
        except Exception:
            self.warningLabel.setStyleSheet("color: #cf1010;")
        self.warningLabel.hide()

        self.viewLayout.addWidget(self.titleLabel)
        self.viewLayout.addWidget(self.subtitleLabel)
        self.viewLayout.addWidget(from_label)
        self.viewLayout.addWidget(name_label)
        self.viewLayout.addWidget(self.nameEdit)
        self.viewLayout.addWidget(self.warningLabel)

        self.yesButton.setText("Переименовать")
        self.cancelButton.setText("Отмена")
        self.widget.setMinimumWidth(420)

    def validate(self) -> bool:
        name = self.nameEdit.text().strip()
        if not name:
            self.warningLabel.setText("Введите название.")
            self.warningLabel.show()
            return False
        if name == self._current_name:
            self.warningLabel.hide()
            return True
        if name in self._existing_names:
            self.warningLabel.setText(f"Пресет «{name}» уже существует.")
            self.warningLabel.show()
            return False
        self.warningLabel.hide()
        return True


class _ResetAllPresetsDialog(MessageBoxBase):
    """Диалог подтверждения сброса всех пресетов (stock qfluentwidgets, без custom CSS)."""

    def __init__(self, parent=None):
        if parent and not parent.isWindow():
            parent = parent.window()
        super().__init__(parent)
        self.titleLabel = SubtitleLabel("Сбросить все пресеты", self.widget)
        self.bodyLabel = BodyLabel(
            "Все пресеты будут сброшены до заводских шаблонов.\n"
            "Пользовательские изменения в пресетах будут потеряны.",
            self.widget,
        )
        self.bodyLabel.setWordWrap(True)
        self.viewLayout.addWidget(self.titleLabel)
        self.viewLayout.addWidget(self.bodyLabel)
        self.yesButton.setText("Сбросить всё")
        self.cancelButton.setText("Отмена")
        self.widget.setMinimumWidth(380)


class Zapret1UserPresetsPage(BasePage):
    preset_switched = pyqtSignal(str)
    preset_created = pyqtSignal(str)
    preset_deleted = pyqtSignal(str)
    back_clicked = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__("Мои пресеты", "", parent)

        # Back navigation (breadcrumb — to Zapret1DirectControlPage)
        try:
            tokens = get_theme_tokens()
            _back_btn = TransparentPushButton()
            _back_btn.setText("Управление")
            _back_btn.setIcon(qta.icon("fa5s.chevron-left", color=tokens.fg_muted))
            _back_btn.setIconSize(QSize(12, 12))
            _back_btn.clicked.connect(self.back_clicked.emit)
            _back_row_layout = QHBoxLayout()
            _back_row_layout.setContentsMargins(0, 0, 0, 0)
            _back_row_layout.setSpacing(0)
            _back_row_layout.addWidget(_back_btn)
            _back_row_layout.addStretch()
            _back_row_widget = QWidget()
            _back_row_widget.setLayout(_back_row_layout)
            self.layout.insertWidget(0, _back_row_widget)
        except Exception:
            pass

        self._presets_model: Optional[_PresetListModel] = None
        self._presets_delegate: Optional[_PresetListDelegate] = None
        self._manager = None
        self._ui_dirty = True  # needs rebuild on next show
        self._page_theme_refresh_scheduled = False
        self._last_page_theme_key: tuple[str, str, str] | None = None

        self._file_watcher: Optional[QFileSystemWatcher] = None
        self._watcher_active = False
        self._watcher_reload_timer = QTimer(self)
        self._watcher_reload_timer.setSingleShot(True)
        self._watcher_reload_timer.timeout.connect(self._reload_presets_from_watcher)

        self._bulk_reset_running = False
        self._layout_resync_timer = QTimer(self)
        self._layout_resync_timer.setSingleShot(True)
        self._layout_resync_timer.timeout.connect(self._resync_layout_metrics)
        self._layout_resync_delayed_timer = QTimer(self)
        self._layout_resync_delayed_timer.setSingleShot(True)
        self._layout_resync_delayed_timer.timeout.connect(self._resync_layout_metrics)

        self._preset_search_timer = QTimer(self)
        self._preset_search_timer.setSingleShot(True)
        self._preset_search_timer.timeout.connect(self._apply_preset_search)
        self._preset_search_input: Optional[QLineEdit] = None

        self._build_ui()

        self._apply_page_theme()

        # Subscribe to central store signals
        try:
            from preset_zapret1.preset_store import PresetStoreV1
            store = PresetStoreV1.instance()
            store.presets_changed.connect(self._on_store_changed)
            store.preset_switched.connect(self._on_store_switched)
        except Exception:
            pass

    def _on_store_changed(self):
        """Central store says the preset list changed."""
        self._ui_dirty = True
        if self._bulk_reset_running:
            return
        if self.isVisible():
            self._load_presets()

    def _on_store_switched(self, _name: str):
        """Central store says the active preset switched."""
        self._ui_dirty = True
        if self._bulk_reset_running:
            return
        if self.isVisible():
            self._load_presets()

    def _get_manager(self):
        if self._manager is None:
            from preset_zapret1 import PresetManagerV1

            # UI: do not restart DPI here; MainWindow handles restart via preset_switched.
            self._manager = PresetManagerV1()
        return self._manager

    def showEvent(self, event):
        super().showEvent(event)
        self._start_watching_presets()
        self._resync_layout_metrics()
        if self._ui_dirty:
            self._load_presets()
        else:
            self._update_presets_view_height()
        self._schedule_layout_resync(include_delayed=True)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self._resync_layout_metrics()
        self._schedule_layout_resync()

    def changeEvent(self, event):  # noqa: N802 (Qt override)
        try:
            if event.type() in (QEvent.Type.StyleChange, QEvent.Type.PaletteChange):
                try:
                    tokens = get_theme_tokens()
                    theme_key = (str(tokens.theme_name), str(tokens.accent_hex), str(tokens.surface_bg))
                    if theme_key == self._last_page_theme_key:
                        return super().changeEvent(event)
                except Exception:
                    pass
                if not self._page_theme_refresh_scheduled:
                    self._page_theme_refresh_scheduled = True
                    QTimer.singleShot(0, self._on_debounced_page_theme_change)
        except Exception:
            pass
        return super().changeEvent(event)

    def _on_debounced_page_theme_change(self) -> None:
        self._page_theme_refresh_scheduled = False
        self._apply_page_theme()
        self._schedule_layout_resync()

    def hideEvent(self, event):
        self._layout_resync_timer.stop()
        self._layout_resync_delayed_timer.stop()
        self._stop_watching_presets()
        super().hideEvent(event)

    def _schedule_layout_resync(self, include_delayed: bool = False):
        self._layout_resync_timer.start(0)
        if include_delayed:
            self._layout_resync_delayed_timer.start(220)

    def _resync_layout_metrics(self):
        self._update_toolbar_buttons_layout()
        self._update_presets_view_height()

    def _start_watching_presets(self):
        try:
            if self._watcher_active:
                return

            from preset_zapret1.preset_storage import get_presets_dir_v1
            presets_dir = get_presets_dir_v1()
            presets_dir.mkdir(parents=True, exist_ok=True)

            if not self._file_watcher:
                self._file_watcher = QFileSystemWatcher(self)
                self._file_watcher.directoryChanged.connect(self._on_presets_dir_changed)
                self._file_watcher.fileChanged.connect(self._on_preset_file_changed)

            dir_path = str(presets_dir)
            if dir_path not in self._file_watcher.directories():
                self._file_watcher.addPath(dir_path)

            self._watcher_active = True
            self._update_watched_preset_files()

        except Exception as e:
            log(f"Ошибка запуска мониторинга пресетов: {e}", "DEBUG")

    def _stop_watching_presets(self):
        try:
            if not self._watcher_active:
                return
            if self._file_watcher:
                directories = self._file_watcher.directories()
                files = self._file_watcher.files()
                if directories:
                    self._file_watcher.removePaths(directories)
                if files:
                    self._file_watcher.removePaths(files)
            self._watcher_active = False
        except Exception as e:
            log(f"Ошибка остановки мониторинга пресетов: {e}", "DEBUG")

    def _update_watched_preset_files(self):
        try:
            if not self._watcher_active or not self._file_watcher:
                return

            from preset_zapret1.preset_storage import get_presets_dir_v1
            presets_dir = get_presets_dir_v1()

            current_files = self._file_watcher.files()
            if current_files:
                self._file_watcher.removePaths(current_files)

            preset_files: list[str] = []
            if presets_dir.exists():
                preset_files.extend([str(p) for p in presets_dir.glob("*.txt") if p.is_file()])
            if preset_files:
                self._file_watcher.addPaths(preset_files)

        except Exception as e:
            log(f"Ошибка обновления мониторинга пресетов: {e}", "DEBUG")

    def _on_presets_dir_changed(self, path: str):
        try:
            log(f"Обнаружены изменения в папке пресетов: {path}", "DEBUG")
            self._update_watched_preset_files()
            self._schedule_presets_reload()
        except Exception as e:
            log(f"Ошибка обработки изменений папки пресетов: {e}", "DEBUG")

    def _on_preset_file_changed(self, path: str):
        try:
            log(f"Обнаружены изменения в пресете: {Path(path).name}", "DEBUG")
            self._schedule_presets_reload()
        except Exception as e:
            log(f"Ошибка обработки изменений пресета: {e}", "DEBUG")

    def _schedule_presets_reload(self, delay_ms: int = 500):
        try:
            self._watcher_reload_timer.stop()
            self._watcher_reload_timer.start(delay_ms)
        except Exception as e:
            log(f"Ошибка планирования обновления пресетов: {e}", "DEBUG")

    def _reload_presets_from_watcher(self):
        if not self.isVisible():
            return
        try:
            from preset_zapret1.preset_store import PresetStoreV1
            PresetStoreV1.instance().notify_presets_changed()
        except Exception:
            self._load_presets()
        self._update_watched_preset_files()

    def _build_ui(self):
        tokens = get_theme_tokens()
        semantic = get_semantic_palette(tokens.theme_name)

        # Telegram configs link
        configs_card = SettingsCard()
        configs_card.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Fixed)
        configs_layout = QHBoxLayout()
        configs_layout.setSpacing(12)
        self._configs_icon = QLabel()
        self._configs_icon.setPixmap(qta.icon("fa5b.telegram", color=tokens.accent_hex).pixmap(18, 18))
        configs_layout.addWidget(self._configs_icon)
        configs_title = StrongBodyLabel(
            "Обменивайтесь категориями на нашем форуме-сайте через Telegram-бота: безопасно и анонимно"
        )
        configs_title.setWordWrap(True)
        configs_title.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        configs_title.setMinimumWidth(0)
        configs_layout.addWidget(configs_title, 1)
        get_configs_btn = ActionButton("Получить конфиги", "fa5s.external-link-alt", accent=True)
        get_configs_btn.setFixedHeight(36)
        get_configs_btn.clicked.connect(self._open_new_configs_post)
        configs_layout.addWidget(get_configs_btn)
        configs_card.add_layout(configs_layout)
        self.add_widget(configs_card)

        # "Restore deleted presets" button
        self._restore_deleted_btn = ActionButton("Восстановить удалённые пресеты", "fa5s.undo")
        self._restore_deleted_btn.setFixedHeight(32)
        self._restore_deleted_btn.clicked.connect(self._on_restore_deleted)
        self._restore_deleted_btn.setVisible(False)
        self.add_widget(self._restore_deleted_btn)

        self.add_spacing(12)

        # Buttons: create + import (above the preset list)
        self._buttons_container = QWidget()
        self._buttons_container.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Fixed)
        self._buttons_container_layout = QVBoxLayout(self._buttons_container)
        self._buttons_container_layout.setContentsMargins(0, 0, 0, 0)
        self._buttons_container_layout.setSpacing(8)

        self._buttons_rows: list[tuple[QWidget, QHBoxLayout]] = []
        for _ in range(4):
            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 0, 0, 0)
            row_layout.setSpacing(12)
            row_widget.setVisible(False)
            self._buttons_container_layout.addWidget(row_widget)
            self._buttons_rows.append((row_widget, row_layout))

        self.create_btn = PrimaryToolButton(FluentIcon.ADD if FluentIcon else None)
        self.create_btn.setFixedSize(36, 36)
        self.create_btn.setToolTip("Создать новый пресет")
        self.create_btn.clicked.connect(self._on_create_clicked)

        self.import_btn = self._create_secondary_row_button("Импорт", "fa5s.file-import")
        self.import_btn.setToolTip("Импорт пресета из файла")
        self.import_btn.clicked.connect(self._on_import_clicked)

        self.reset_all_btn = self._create_secondary_row_button("Сбросить", "fa5s.undo")
        self.reset_all_btn.setToolTip("Сбросить все настройки пресетов до заводских")
        self.reset_all_btn.clicked.connect(self._on_reset_all_presets_clicked)

        self.presets_info_btn = self._create_secondary_row_button("Вики по пресетам", "fa5s.info-circle")
        self.presets_info_btn.clicked.connect(self._open_presets_info)

        self.info_btn = self._create_secondary_row_button("Что это такое?", "fa5s.question-circle")
        self.info_btn.clicked.connect(self._on_info_clicked)

        self._toolbar_buttons = [
            self.create_btn,
            self.import_btn,
            self.reset_all_btn,
            self.presets_info_btn,
            self.info_btn,
        ]
        self._update_toolbar_buttons_layout()
        self.add_widget(self._buttons_container)

        self.add_spacing(4)

        # Search presets by name (filters the list).
        self._preset_search_input = LineEdit()
        self._preset_search_input.setPlaceholderText("Поиск пресетов по имени...")
        self._preset_search_input.setClearButtonEnabled(True)
        self._preset_search_input.setFixedHeight(34)
        self._preset_search_input.setProperty("noDrag", True)
        self._preset_search_input.textChanged.connect(self._on_preset_search_text_changed)
        self.add_widget(self._preset_search_input)

        self.presets_list = _LinkedWheelListView(self)
        self.presets_list.setObjectName("userPresetsList")
        self.presets_list.setMouseTracking(True)
        self.presets_list.setSelectionMode(QListView.SelectionMode.NoSelection)
        self.presets_list.setEditTriggers(QListView.EditTrigger.NoEditTriggers)
        self.presets_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.presets_list.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.presets_list.setVerticalScrollMode(QListView.ScrollMode.ScrollPerPixel)
        self.presets_list.setUniformItemSizes(False)
        self.presets_list.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.presets_list.setProperty("uiList", True)
        self.presets_list.setProperty("noDrag", True)
        self.presets_list.viewport().setProperty("noDrag", True)

        self._presets_model = _PresetListModel(self.presets_list)
        self._presets_delegate = _PresetListDelegate(self.presets_list)
        self._presets_delegate.action_triggered.connect(self._on_preset_list_action)
        self.presets_list.setModel(self._presets_model)
        self.presets_list.setItemDelegate(self._presets_delegate)
        self.presets_list.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Fixed)
        self.presets_list.setFrameShape(QFrame.Shape.NoFrame)
        self.presets_list.verticalScrollBar().setSingleStep(28)
        try:
            from qfluentwidgets import SmoothScrollDelegate
            self._presets_scroll_delegate = SmoothScrollDelegate(self.presets_list, useAni=True)
        except Exception:
            pass
        self.add_widget(self.presets_list)

        # Make outer page scrolling feel less sluggish on long lists.
        self.verticalScrollBar().setSingleStep(48)

    def _on_info_clicked(self) -> None:
        if MessageBox:
            box = MessageBox(
                "Что это такое?",
                'Здесь кнопка для нубов — "хочу чтобы нажал и всё работало". '
                "Выбираете любой пресет — тыкаете — перезагружаете вкладку и смотрите, "
                "что ресурс открывается (или не открывается). Если не открывается — тыкаете на следующий пресет. "
                "Также здесь можно создавать, импортировать, экспортировать и переключать пользовательские пресеты.",
                self.window(),
            )
            box.cancelButton.hide()
            box.exec()

    def _create_secondary_row_button(self, text: str, icon_name: str) -> ActionButton:
        btn = ActionButton(text, icon_name)
        btn.setFixedHeight(32)
        return btn

    def _apply_page_theme(self) -> None:
        try:
            tokens = get_theme_tokens()
            theme_key = (str(tokens.theme_name), str(tokens.accent_hex), str(tokens.surface_bg))
            if theme_key == self._last_page_theme_key:
                return

            semantic = get_semantic_palette(tokens.theme_name)

            if getattr(self, "_configs_icon", None) is not None:
                self._configs_icon.setPixmap(qta.icon("fa5b.telegram", color=tokens.accent_hex).pixmap(18, 18))

            # _restore_deleted_btn is ActionButton — self-styling, skip explicit update

            # create_btn is PrimaryToolButton — self-styling, skip explicit update
            # import_btn / presets_info_btn are ActionButton — self-styling, skip explicit update

            if getattr(self, "reset_all_btn", None) is not None:
                try:
                    self.reset_all_btn.setIcon(qta.icon("fa5s.undo", color=tokens.fg))
                except Exception:
                    pass

            if getattr(self, "presets_list", None) is not None:
                self.presets_list.viewport().update()

            self._last_page_theme_key = theme_key

        except Exception as e:
            log(f"Ошибка применения темы на странице пресетов: {e}", "DEBUG")

    def _content_inner_width(self) -> int:
        margins = self.layout.contentsMargins()
        return max(0, self.viewport().width() - margins.left() - margins.right())

    def _compute_toolbar_rows(self, available_width: int) -> list[list[QPushButton]]:
        buttons = getattr(self, "_toolbar_buttons", [])
        if not buttons:
            return []

        if available_width <= 0:
            return [buttons]

        spacing = 12
        rows: list[list[QPushButton]] = []
        current_row: list[QPushButton] = []
        current_width = 0

        for button in buttons:
            button_width = button.sizeHint().width()
            if not current_row:
                current_row = [button]
                current_width = button_width
                continue

            next_width = current_width + spacing + button_width
            if next_width <= available_width:
                current_row.append(button)
                current_width = next_width
                continue

            rows.append(current_row)
            current_row = [button]
            current_width = button_width

        if current_row:
            rows.append(current_row)

        return rows

    def _clear_toolbar_row(self, row_layout: QHBoxLayout):
        while row_layout.count():
            row_layout.takeAt(0)

    def _update_toolbar_buttons_layout(self):
        rows = getattr(self, "_buttons_rows", None)
        if not rows:
            return

        assigned_rows = self._compute_toolbar_rows(self._content_inner_width())

        for index, (row_widget, row_layout) in enumerate(rows):
            self._clear_toolbar_row(row_layout)
            row_buttons = assigned_rows[index] if index < len(assigned_rows) else []

            if row_buttons:
                for button in row_buttons:
                    row_layout.addWidget(button)
                row_layout.addStretch(1)
                row_widget.setVisible(True)
            else:
                row_widget.setVisible(False)

    def _is_game_filter_preset_name(self, name: str) -> bool:
        return "game filter" in name.lower()

    def _is_all_tcp_udp_preset_name(self, name: str) -> bool:
        return "all tcp" in name.lower()

    def _format_modified_timestamp(self, modified: str) -> str:
        if not modified:
            return ""
        try:
            dt = datetime.fromisoformat(modified.replace("Z", "+00:00"))
            return dt.strftime("%d.%m.%Y %H:%M")
        except Exception:
            return modified

    def _on_preset_search_text_changed(self, _text: str) -> None:
        # Debounce to avoid reloading on every keystroke.
        try:
            self._preset_search_timer.start(180)
        except Exception:
            self._load_presets()

    def _apply_preset_search(self) -> None:
        if not self.isVisible():
            self._ui_dirty = True
            return
        self._load_presets()

    def _update_presets_view_height(self):
        if not self._presets_model or not hasattr(self, "presets_list"):
            return

        viewport_height = self.viewport().height()
        if viewport_height <= 0:
            return

        top = max(0, self.presets_list.geometry().top())
        bottom_margin = self.layout.contentsMargins().bottom()
        target_height = max(220, viewport_height - top - bottom_margin)

        if self.presets_list.minimumHeight() != target_height:
            self.presets_list.setMinimumHeight(target_height)
        if self.presets_list.maximumHeight() != target_height:
            self.presets_list.setMaximumHeight(target_height)

    def _show_inline_action_create(self):
        try:
            manager = self._get_manager()
            existing = manager.list_presets()
        except Exception:
            existing = []

        dlg = _CreatePresetDialog(existing, self.window())
        if not dlg.exec():
            return

        name = dlg.nameEdit.text().strip()
        from_current = getattr(dlg, "_source", "current") == "current"

        try:
            manager = self._get_manager()
            preset = manager.create_preset(name, from_current=from_current)
            if not preset:
                InfoBar.error(title="Ошибка", content="Не удалось создать пресет.", parent=self.window())
                return
            log(f"Создан пресет '{name}'", "INFO")
            self.preset_created.emit(name)
            self._load_presets()
        except Exception as e:
            log(f"Ошибка создания пресета: {e}", "ERROR")
            InfoBar.error(title="Ошибка", content=f"Ошибка: {e}", parent=self.window())

    def _show_inline_action_rename(self, current_name: str):
        try:
            manager = self._get_manager()
            existing = manager.list_presets()
        except Exception:
            existing = []

        dlg = _RenamePresetDialog(current_name, existing, self.window())
        if not dlg.exec():
            return

        new_name = dlg.nameEdit.text().strip()
        if not new_name or new_name == current_name:
            return

        try:
            manager = self._get_manager()
            if not manager.rename_preset(current_name, new_name):
                InfoBar.error(title="Ошибка", content="Не удалось переименовать пресет.", parent=self.window())
                return
            log(f"Пресет '{current_name}' переименован в '{new_name}'", "INFO")
            self._load_presets()
        except Exception as e:
            log(f"Ошибка переименования пресета: {e}", "ERROR")
            InfoBar.error(title="Ошибка", content=f"Ошибка: {e}", parent=self.window())

    def _on_create_clicked(self):
        self._show_inline_action_create()

    def _on_import_clicked(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Импортировать пресет",
            "",
            "Preset files (*.txt);;All files (*.*)",
        )

        if not file_path:
            return

        try:
            manager = self._get_manager()
            name = Path(file_path).stem

            if manager.preset_exists(name):
                box = MessageBox(
                    "Пресет существует",
                    f"Пресет '{name}' уже существует. Импортировать с другим именем?",
                    self.window(),
                )
                if box.exec():
                    counter = 1
                    while manager.preset_exists(f"{name}_{counter}"):
                        counter += 1
                    name = f"{name}_{counter}"
                else:
                    return

            if manager.import_preset(Path(file_path), name):
                log(f"Импортирован пресет '{name}'", "INFO")
                self.preset_created.emit(name)
                self._load_presets()
            else:
                InfoBar.warning(title="Ошибка", content="Не удалось импортировать пресет", parent=self.window())

        except Exception as e:
            log(f"Ошибка импорта пресета: {e}", "ERROR")
            InfoBar.error(title="Ошибка", content=f"Ошибка импорта: {e}", parent=self.window())

    def _on_reset_all_presets_clicked(self):
        dlg = _ResetAllPresetsDialog(self.window())
        if not dlg.exec():
            return

        self._bulk_reset_running = True
        try:
            manager = self._get_manager()

            # 1) Refresh templates and create any missing presets from templates.
            try:
                from preset_zapret1.preset_defaults import invalidate_templates_cache_v1, ensure_v1_templates_copied_to_presets
                invalidate_templates_cache_v1()
                ensure_v1_templates_copied_to_presets()
            except Exception as e:
                log(f"Ошибка обновления шаблонов пресетов: {e}", "DEBUG")

            # 2) Reload store so newly created presets appear in manager.list_presets().
            try:
                manager.invalidate_preset_cache(None)
            except Exception:
                pass

            preset_names = manager.list_presets()
            ordered_names = sorted(preset_names, key=lambda s: s.lower())
            if not ordered_names:
                self._show_reset_all_result(0, 0)
                return

            original_active = (manager.get_active_preset_name() or "").strip()

            # Reset the active preset last, then sync it once.
            if original_active and original_active in ordered_names:
                ordered_names = [n for n in ordered_names if n != original_active] + [original_active]

            success_count = 0
            failed: list[str] = []

            for name in ordered_names:
                ok = manager.reset_preset_to_default_template(
                    name,
                    make_active=False,
                    sync_active_file=False,
                    emit_switched=False,
                    invalidate_templates=False,
                )
                if ok:
                    success_count += 1
                else:
                    failed.append(name)

            # 3) Re-apply active preset once from presets/ file.
            # Use switch_preset() to copy the just-reset file as-is into
            # preset-zapret1.txt (avoid model re-generation drift).
            active_name = (original_active or (manager.get_active_preset_name() or "")).strip()
            if active_name:
                if not manager.switch_preset(active_name, reload_dpi=False):
                    log(f"Не удалось применить активный пресет после сброса: {active_name}", "WARNING")

            self._load_presets()

            total = len(ordered_names)
            if failed:
                log(f"Сброс пресетов завершён частично: успешно={success_count}, ошибки={len(failed)}", "WARNING")
            else:
                log(f"Сброшены все пресеты к шаблонам: {success_count}", "INFO")

            self._show_reset_all_result(success_count, total)

        except Exception as e:
            log(f"Ошибка массового сброса пресетов: {e}", "ERROR")
            InfoBar.error(title="Ошибка", content=f"Ошибка сброса пресетов: {e}", parent=self.window())
        finally:
            self._bulk_reset_running = False

    def _show_reset_all_result(self, success_count: int, total_count: int) -> None:
        total = int(total_count or 0)
        ok = int(success_count or 0)
        try:
            self.reset_all_btn.setText(f"{ok}/{total}")
            icon_name = "fa5s.check" if total > 0 and ok >= total else "fa5s.exclamation-triangle"
            self.reset_all_btn.setIcon(qta.icon(icon_name, color=get_theme_tokens().fg))
        except Exception:
            pass
        QTimer.singleShot(3000, self._restore_reset_all_button_label)

    def _restore_reset_all_button_label(self) -> None:
        try:
            self.reset_all_btn.setText("Сбросить все пресеты")
            self.reset_all_btn.setIcon(qta.icon("fa5s.undo", color=get_theme_tokens().fg))
        except Exception:
            pass

    def _load_presets(self):
        self._ui_dirty = False
        try:
            # ── Read data from PresetStore (in-memory, no disk I/O) ──────
            from preset_zapret1.preset_store import PresetStoreV1
            store = PresetStoreV1.instance()
            all_presets = store.get_all_presets()       # {name: Preset}
            active_name = store.get_active_preset_name()
            sorted_names = sorted(all_presets.keys(), key=lambda s: s.lower())

            query = ""
            try:
                if self._preset_search_input is not None:
                    query = (self._preset_search_input.text() or "").strip().lower()
            except Exception:
                query = ""

            def matches(name: str) -> bool:
                if not query:
                    return True
                return query in name.lower()

            all_tcp_names = [name for name in sorted_names if self._is_all_tcp_udp_preset_name(name)]
            regular_names = [
                name
                for name in sorted_names
                if not self._is_game_filter_preset_name(name) and not self._is_all_tcp_udp_preset_name(name)
            ]
            game_filter_names = [
                name
                for name in sorted_names
                if self._is_game_filter_preset_name(name) and not self._is_all_tcp_udp_preset_name(name)
            ]

            # Apply search filter per group to keep the existing ordering.
            regular_names = [name for name in regular_names if matches(name)]
            game_filter_names = [name for name in game_filter_names if matches(name)]
            all_tcp_names = [name for name in all_tcp_names if matches(name)]

            rows: list[dict[str, object]] = []

            def add_preset_row(name: str):
                preset = all_presets.get(name)
                if not preset:
                    return
                rows.append(
                    {
                        "kind": "preset",
                        "name": name,
                        "description": getattr(preset, "description", "") or "",
                        "date": self._format_modified_timestamp(getattr(preset, "modified", "") or ""),
                        "is_active": name == active_name,
                        "icon_color": _normalize_preset_icon_color(getattr(preset, "icon_color", None)),
                    }
                )

            for name in regular_names:
                add_preset_row(name)

            if game_filter_names:
                rows.append({"kind": "section", "text": "Игры (game filter)"})
                for name in game_filter_names:
                    add_preset_row(name)

            if all_tcp_names:
                rows.append({"kind": "section", "text": "Все сайты (ALL TCP/UDP)"})
                for name in all_tcp_names:
                    add_preset_row(name)

            if not rows:
                if query:
                    rows.append({"kind": "empty", "text": "Ничего не найдено."})
                else:
                    rows.append({"kind": "empty", "text": "Нет пресетов. Создайте новый или импортируйте из файла."})

            if self._presets_delegate:
                self._presets_delegate.reset_interaction_state()
            if self._presets_model:
                self._presets_model.set_rows(rows)

            # Update restore-deleted button visibility
            try:
                from preset_zapret1.preset_storage import get_deleted_preset_names
                has_deleted = bool(get_deleted_preset_names())
                self._restore_deleted_btn.setVisible(has_deleted)
            except Exception:
                self._restore_deleted_btn.setVisible(False)

            self._update_presets_view_height()
            self._schedule_layout_resync()

        except Exception as e:
            log(f"Ошибка загрузки пресетов: {e}", "ERROR")

    def _on_preset_list_action(self, action: str, name: str):
        handlers = {
            "activate": self._on_activate_preset,
            "rename": self._on_rename_preset,
            "duplicate": self._on_duplicate_preset,
            "reset": self._on_reset_preset,
            "delete": self._on_delete_preset,
            "export": self._on_export_preset,
        }
        handler = handlers.get(action)
        if handler:
            handler(name)

    def _on_activate_preset(self, name: str):
        try:
            manager = self._get_manager()

            if manager.switch_preset(name, reload_dpi=False):
                log(f"Активирован пресет '{name}'", "INFO")
                self.preset_switched.emit(name)
                self._load_presets()
            else:
                InfoBar.warning(title="Ошибка", content=f"Не удалось активировать пресет '{name}'", parent=self.window())

        except Exception as e:
            log(f"Ошибка активации пресета: {e}", "ERROR")
            InfoBar.error(title="Ошибка", content=f"Ошибка: {e}", parent=self.window())

    def _on_rename_preset(self, name: str):
        self._show_inline_action_rename(name)

    def _on_duplicate_preset(self, name: str):
        try:
            manager = self._get_manager()

            counter = 1
            new_name = f"{name} (копия)"
            while manager.preset_exists(new_name):
                counter += 1
                new_name = f"{name} (копия {counter})"

            if manager.duplicate_preset(name, new_name):
                log(f"Пресет '{name}' дублирован как '{new_name}'", "INFO")
                self.preset_created.emit(new_name)
                self._load_presets()
            else:
                InfoBar.warning(title="Ошибка", content="Не удалось дублировать пресет", parent=self.window())

        except Exception as e:
            log(f"Ошибка дублирования пресета: {e}", "ERROR")
            InfoBar.error(title="Ошибка", content=f"Ошибка: {e}", parent=self.window())

    def _on_reset_preset(self, name: str):
        try:
            manager = self._get_manager()

            if not manager.reset_preset_to_default_template(name):
                InfoBar.warning(title="Ошибка", content="Не удалось сбросить пресет к настройкам шаблона", parent=self.window())
                return

            log(f"Сброшен пресет '{name}' к шаблону", "INFO")
            self.preset_switched.emit(name)
            self._load_presets()

        except Exception as e:
            log(f"Ошибка сброса пресета: {e}", "ERROR")
            InfoBar.error(title="Ошибка", content=f"Ошибка: {e}", parent=self.window())

    def _on_delete_preset(self, name: str):
        try:
            manager = self._get_manager()

            if manager.delete_preset(name):
                log(f"Удалён пресет '{name}'", "INFO")
                # Mark as deleted so it can be restored later (if it has a matching template)
                try:
                    from preset_zapret1.preset_defaults import mark_preset_deleted
                    mark_preset_deleted(name)
                except Exception:
                    pass
                self.preset_deleted.emit(name)
                self._load_presets()
            else:
                InfoBar.warning(title="Ошибка", content="Не удалось удалить пресет", parent=self.window())

        except Exception as e:
            log(f"Ошибка удаления пресета: {e}", "ERROR")
            InfoBar.error(title="Ошибка", content=f"Ошибка: {e}", parent=self.window())

    def _on_export_preset(self, name: str):
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Экспортировать пресет",
            f"{name}.txt",
            "Preset files (*.txt);;All files (*.*)",
        )

        if not file_path:
            return

        try:
            manager = self._get_manager()

            if manager.export_preset(name, Path(file_path)):
                log(f"Экспортирован пресет '{name}' в {file_path}", "INFO")
                InfoBar.success(title="Успех", content=f"Пресет экспортирован: {file_path}", parent=self.window())
            else:
                InfoBar.warning(title="Ошибка", content="Не удалось экспортировать пресет", parent=self.window())

        except Exception as e:
            log(f"Ошибка экспорта пресета: {e}", "ERROR")
            InfoBar.error(title="Ошибка", content=f"Ошибка: {e}", parent=self.window())

    def _on_restore_deleted(self):
        """Restore all previously deleted presets that have matching templates."""
        try:
            from preset_zapret1.preset_defaults import clear_all_deleted_presets, ensure_templates_copied_to_presets
            clear_all_deleted_presets()
            ensure_v1_templates_copied_to_presets()
            log("Восстановлены удалённые пресеты", "INFO")
            self._load_presets()
        except Exception as e:
            log(f"Ошибка восстановления удалённых пресетов: {e}", "ERROR")
            InfoBar.error(title="Ошибка", content=f"Ошибка восстановления: {e}", parent=self.window())

    def _on_preset_switched_callback(self, name: str):
        _ = name

    def _on_dpi_reload_needed(self):
        try:
            widget = self
            while widget:
                if hasattr(widget, "dpi_controller"):
                    widget.dpi_controller.restart_dpi_async()
                    log("DPI перезапущен после смены пресета", "INFO")
                    return
                widget = widget.parent()

            from PyQt6.QtWidgets import QApplication
            for w in QApplication.topLevelWidgets():
                if hasattr(w, "dpi_controller"):
                    w.dpi_controller.restart_dpi_async()
                    log("DPI перезапущен после смены пресета", "INFO")
                    return

        except Exception as e:
            log(f"Ошибка перезапуска DPI: {e}", "ERROR")

    def _open_presets_info(self):
        """Открывает страницу с информацией о пресетах."""
        try:
            from config.urls import PRESET_INFO_URL

            webbrowser.open(PRESET_INFO_URL)
            log(f"Открыта страница о пресетах: {PRESET_INFO_URL}", "INFO")
        except Exception as e:
            log(f"Не удалось открыть страницу о пресетах: {e}", "ERROR")

    def _open_new_configs_post(self):
        try:
            from config.telegram_links import open_telegram_link

            open_telegram_link("nozapretinrussia_bot")
        except Exception as e:
            log(f"Ошибка открытия Telegram: {e}", "ERROR")
            InfoBar.warning(title="Ошибка", content=f"Не удалось открыть Telegram: {e}", parent=self.window())
