# ui/pages/zapret1/strategy_detail_page_v1.py
"""Zapret 1 strategy detail page with Zapret 2-style layout."""

from __future__ import annotations

from typing import Any

from PyQt6.QtCore import Qt, pyqtSignal, QTimer
from PyQt6.QtWidgets import QWidget, QFrame, QHBoxLayout, QVBoxLayout, QLabel, QPushButton
from PyQt6.QtGui import QFont

from ui.pages.base_page import BasePage
from ui.compat_widgets import ActionButton, RefreshButton, SettingsCard
from ui.widgets.direct_zapret2_strategies_tree import DirectZapret2StrategiesTree, StrategyTreeRow
from log import log

try:
    from qfluentwidgets import (
        BodyLabel,
        CaptionLabel,
        StrongBodyLabel,
        TitleLabel,
        SubtitleLabel,
        LineEdit,
        ComboBox,
        TextEdit,
        BreadcrumbBar,
        MessageBoxBase,
        IndeterminateProgressRing,
        PixmapLabel,
        InfoBar,
        TransparentPushButton,
        SwitchButton,
    )

    _HAS_FLUENT = True
except ImportError:
    from PyQt6.QtWidgets import (  # type: ignore
        QLabel as BodyLabel,
        QLabel as CaptionLabel,
        QLabel as StrongBodyLabel,
        QLabel as TitleLabel,
        QLabel as SubtitleLabel,
        QLineEdit as LineEdit,
        QComboBox as ComboBox,
        QTextEdit as TextEdit,
        QDialog as MessageBoxBase,
        QCheckBox as SwitchButton,
    )

    BreadcrumbBar = None  # type: ignore
    IndeterminateProgressRing = QWidget  # type: ignore
    PixmapLabel = QLabel  # type: ignore
    InfoBar = None  # type: ignore
    TransparentPushButton = QPushButton  # type: ignore
    _HAS_FLUENT = False

try:
    import qtawesome as qta

    _HAS_QTA = True
except ImportError:
    qta = None  # type: ignore
    _HAS_QTA = False


_LABEL_ORDER = {
    "recommended": 0,
    "stable": 1,
    None: 2,
    "none": 2,
    "experimental": 3,
    "game": 4,
    "caution": 5,
}


class _ArgsEditorDialog(MessageBoxBase):  # type: ignore[misc, valid-type]
    """Диалог ручного редактирования аргументов стратегии."""

    def __init__(self, initial_text: str = "", parent=None):
        super().__init__(parent)
        if not _HAS_FLUENT:
            return

        self._title_lbl = SubtitleLabel("Аргументы стратегии")
        self.viewLayout.addWidget(self._title_lbl)

        hint = CaptionLabel("Один аргумент на строку. Изменяет только выбранную категорию.")
        self.viewLayout.addWidget(hint)

        self._text_edit = TextEdit()
        try:
            from config.reg import get_smooth_scroll_enabled
            from qfluentwidgets.common.smooth_scroll import SmoothMode

            smooth_enabled = get_smooth_scroll_enabled()
            mode = SmoothMode.COSINE if smooth_enabled else SmoothMode.NO_SMOOTH
            delegate = (
                getattr(self._text_edit, "scrollDelegate", None)
                or getattr(self._text_edit, "scrollDelagate", None)
                or getattr(self._text_edit, "delegate", None)
            )
            if delegate is not None:
                if hasattr(delegate, "useAni"):
                    if not hasattr(delegate, "_zapret_base_use_ani"):
                        delegate._zapret_base_use_ani = bool(delegate.useAni)
                    delegate.useAni = bool(delegate._zapret_base_use_ani) if smooth_enabled else False
                for smooth_attr in ("verticalSmoothScroll", "horizonSmoothScroll"):
                    smooth = getattr(delegate, smooth_attr, None)
                    smooth_setter = getattr(smooth, "setSmoothMode", None)
                    if callable(smooth_setter):
                        smooth_setter(mode)

            setter = getattr(self._text_edit, "setSmoothMode", None)
            if callable(setter):
                try:
                    setter(mode, Qt.Orientation.Vertical)
                except TypeError:
                    setter(mode)
        except Exception:
            pass
        self._text_edit.setPlaceholderText(
            "Например:\n--dpi-desync=multisplit\n--dpi-desync-split-pos=1"
        )
        self._text_edit.setMinimumWidth(460)
        self._text_edit.setMinimumHeight(150)
        self._text_edit.setMaximumHeight(260)
        self._text_edit.setFont(QFont("Consolas", 10))
        self._text_edit.setPlainText(initial_text)
        self.viewLayout.addWidget(self._text_edit)

        self.yesButton.setText("Сохранить")
        self.cancelButton.setText("Отмена")

    def validate(self) -> bool:
        return True

    def get_text(self) -> str:
        if hasattr(self, "_text_edit"):
            return self._text_edit.toPlainText()
        return ""


class Zapret1StrategyDetailPage(BasePage):
    """Страница выбора стратегии для одной категории Zapret 1."""

    strategy_selected = pyqtSignal(str, str)  # category_key, strategy_id
    back_clicked = pyqtSignal()  # go to categories list
    navigate_to_control = pyqtSignal()  # go to control page

    def __init__(self, parent=None):
        super().__init__(title="", subtitle="", parent=parent)
        self.parent_app = parent

        self._category_key: str = ""
        self._category_info: dict[str, Any] = {}
        self._preset_manager = None

        self._strategies: dict[str, dict] = {}
        self._current_strategy_id: str = "none"
        self._sort_mode: str = "recommended"  # recommended | alpha_asc | alpha_desc
        self._search_text: str = ""

        self._breadcrumb = None
        self._tree: DirectZapret2StrategiesTree | None = None
        self._refresh_btn: RefreshButton | None = None
        self._search_edit: Any = None
        self._sort_combo: Any = None
        self._spinner: Any = None
        self._success_icon: Any = None
        self._title_label: Any = None
        self._subtitle_label: Any = None
        self._selected_label: Any = None
        self._desc_label: Any = None
        self._args_preview_label: Any = None
        self._empty_label: Any = None
        self._edit_args_btn: Any = None
        self._enable_toggle: Any = None
        self._filter_mode_frame: Any = None
        self._filter_mode_selector: Any = None

        self._last_enabled_strategy_id: str = ""

        self._success_timer = QTimer(self)
        self._success_timer.setSingleShot(True)
        self._success_timer.timeout.connect(self._hide_success)

        self._build_ui()

    # ------------------------------------------------------------------
    # UI
    # ------------------------------------------------------------------

    def _build_ui(self) -> None:
        try:
            self.layout.setSizeConstraint(QVBoxLayout.SizeConstraint.SetDefaultConstraint)
        except Exception:
            pass

        try:
            if hasattr(self, "content") and self.content is not None:
                self.content.setMaximumSize(16777215, 16777215)
        except Exception:
            pass

        if self.title_label is not None:
            self.title_label.hide()
        if self.subtitle_label is not None:
            self.subtitle_label.hide()

        # Header with breadcrumb + title/subtitle
        header = QFrame()
        header.setFrameShape(QFrame.Shape.NoFrame)
        header.setStyleSheet("background: transparent; border: none;")
        header_layout = QVBoxLayout(header)
        header_layout.setContentsMargins(0, 0, 0, 10)
        header_layout.setSpacing(4)

        self._setup_breadcrumb()
        if self._breadcrumb is not None:
            header_layout.addWidget(self._breadcrumb)

        self._title_label = TitleLabel("Категория")
        header_layout.addWidget(self._title_label)

        subtitle_row = QHBoxLayout()
        subtitle_row.setContentsMargins(0, 0, 0, 0)
        subtitle_row.setSpacing(6)

        if _HAS_FLUENT:
            self._spinner = IndeterminateProgressRing()
            self._spinner.setFixedSize(16, 16)
            self._spinner.setStrokeWidth(2)
        else:
            self._spinner = QWidget()
        self._spinner.hide()
        subtitle_row.addWidget(self._spinner)

        self._success_icon = PixmapLabel()
        self._success_icon.setFixedSize(16, 16)
        self._success_icon.hide()
        subtitle_row.addWidget(self._success_icon)

        self._subtitle_label = BodyLabel("")
        subtitle_row.addWidget(self._subtitle_label)

        self._selected_label = CaptionLabel("")
        self._selected_label.setFont(QFont("Segoe UI", 10))
        subtitle_row.addWidget(self._selected_label, 1)

        header_layout.addLayout(subtitle_row)

        self._desc_label = BodyLabel("")
        self._desc_label.setWordWrap(True)
        header_layout.addWidget(self._desc_label)

        self.add_widget(header)

        # Toolbar card
        toolbar_card = SettingsCard()
        toolbar_layout = QVBoxLayout()
        toolbar_layout.setSpacing(8)

        state_row = QHBoxLayout()
        state_row.setSpacing(8)

        state_label = BodyLabel("Обход для категории")
        state_row.addWidget(state_label)

        self._enable_toggle = SwitchButton(parent=self)
        if hasattr(self._enable_toggle, "setOnText"):
            self._enable_toggle.setOnText("Включено")
        if hasattr(self._enable_toggle, "setOffText"):
            self._enable_toggle.setOffText("Выключено")
        if hasattr(self._enable_toggle, "checkedChanged"):
            self._enable_toggle.checkedChanged.connect(self._on_enable_toggled)
        else:
            self._enable_toggle.toggled.connect(self._on_enable_toggled)
        state_row.addWidget(self._enable_toggle)

        self._filter_mode_frame = QWidget()
        filter_row = QHBoxLayout(self._filter_mode_frame)
        filter_row.setContentsMargins(0, 0, 0, 0)
        filter_row.setSpacing(6)
        filter_row.addWidget(CaptionLabel("Фильтр:"))

        self._filter_mode_selector = SwitchButton(parent=self)
        if hasattr(self._filter_mode_selector, "setOnText"):
            self._filter_mode_selector.setOnText("IPset")
        if hasattr(self._filter_mode_selector, "setOffText"):
            self._filter_mode_selector.setOffText("Hostlist")
        if hasattr(self._filter_mode_selector, "checkedChanged"):
            self._filter_mode_selector.checkedChanged.connect(
                lambda checked: self._on_filter_mode_changed("ipset" if checked else "hostlist")
            )
        else:
            self._filter_mode_selector.toggled.connect(
                lambda checked: self._on_filter_mode_changed("ipset" if checked else "hostlist")
            )
        filter_row.addWidget(self._filter_mode_selector)
        self._filter_mode_frame.hide()
        state_row.addWidget(self._filter_mode_frame)
        state_row.addStretch(1)

        toolbar_layout.addLayout(state_row)

        controls_row = QHBoxLayout()
        controls_row.setSpacing(8)

        self._refresh_btn = RefreshButton()
        self._refresh_btn.clicked.connect(self._reload_category)
        controls_row.addWidget(self._refresh_btn)

        self._search_edit = LineEdit()
        self._search_edit.setPlaceholderText("Поиск стратегии по названию или аргументам")
        self._search_edit.textChanged.connect(self._on_search_text_changed)
        controls_row.addWidget(self._search_edit, 1)

        self._sort_combo = ComboBox()
        self._sort_combo.addItem("По рекомендации", userData="recommended")
        self._sort_combo.addItem("По алфавиту A-Z", userData="alpha_asc")
        self._sort_combo.addItem("По алфавиту Z-A", userData="alpha_desc")
        self._sort_combo.currentIndexChanged.connect(self._on_sort_combo_changed)
        controls_row.addWidget(self._sort_combo)

        self._edit_args_btn = ActionButton("Редактировать аргументы", "fa5s.edit", accent=False)
        self._edit_args_btn.clicked.connect(self._open_args_editor)
        controls_row.addWidget(self._edit_args_btn)

        toolbar_layout.addLayout(controls_row)

        self._args_preview_label = CaptionLabel("(нет аргументов)")
        self._args_preview_label.setWordWrap(True)
        self._args_preview_label.setFont(QFont("Consolas", 9))
        toolbar_layout.addWidget(self._args_preview_label)

        toolbar_card.add_layout(toolbar_layout)
        self.add_widget(toolbar_card)

        # Strategies tree card
        list_card = SettingsCard("Стратегии")
        list_layout = QVBoxLayout()
        list_layout.setContentsMargins(0, 0, 0, 0)
        list_layout.setSpacing(8)

        self._tree = DirectZapret2StrategiesTree(self)
        self._tree.strategy_clicked.connect(self._on_strategy_selected)
        list_layout.addWidget(self._tree, 1)

        self._empty_label = CaptionLabel("Нет доступных стратегий. Проверьте %APPDATA%\\zapret\\direct_zapret1\\")
        self._empty_label.setWordWrap(True)
        self._empty_label.hide()
        list_layout.addWidget(self._empty_label)

        list_card.add_layout(list_layout)
        self.add_widget(list_card, 1)

    def _setup_breadcrumb(self) -> None:
        if _HAS_FLUENT and BreadcrumbBar is not None:
            try:
                self._breadcrumb = BreadcrumbBar(self)
                self._rebuild_breadcrumb()
                self._breadcrumb.currentItemChanged.connect(self._on_breadcrumb_changed)
                return
            except Exception:
                pass

        self._breadcrumb = None
        try:
            back_btn = TransparentPushButton(parent=self)
            back_btn.setText("← Стратегии Zapret 1")
            back_btn.clicked.connect(self.back_clicked.emit)
            self.add_widget(back_btn)
        except Exception:
            pass

    def _rebuild_breadcrumb(self) -> None:
        if self._breadcrumb is None:
            return

        cat_name = self._category_info.get("full_name", self._category_key) if self._category_key else "Категория"
        self._breadcrumb.blockSignals(True)
        try:
            self._breadcrumb.clear()
            self._breadcrumb.addItem("control", "Управление")
            self._breadcrumb.addItem("strategies", "Прямой запуск Zapret 1")
            self._breadcrumb.addItem("detail", cat_name)
        finally:
            self._breadcrumb.blockSignals(False)

    def _on_breadcrumb_changed(self, key: str) -> None:
        self._rebuild_breadcrumb()
        if key == "strategies":
            self.back_clicked.emit()
        elif key == "control":
            self.navigate_to_control.emit()

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def set_category(self, category_key: str, category_info: dict, preset_manager) -> None:
        self._category_key = str(category_key or "").strip().lower()
        self._category_info = self._normalize_category_info(category_key, category_info)
        self._preset_manager = preset_manager
        self._current_strategy_id = self._load_current_strategy_id()
        if self._current_strategy_id and self._current_strategy_id != "none":
            self._last_enabled_strategy_id = self._current_strategy_id

        self._update_header_labels()
        self._rebuild_breadcrumb()
        self._reload_category()

    def showEvent(self, event):
        super().showEvent(event)
        self._rebuild_breadcrumb()
        if self._category_key:
            QTimer.singleShot(0, self._reload_category)

    # ------------------------------------------------------------------
    # Data mapping / loading
    # ------------------------------------------------------------------

    @staticmethod
    def _normalize_category_info(category_key: str, category_info: Any) -> dict[str, Any]:
        if isinstance(category_info, dict):
            info = dict(category_info)
            info.setdefault("key", category_key)
            info.setdefault("full_name", category_key)
            info.setdefault("description", "")
            info.setdefault("base_filter", "")
            info.setdefault("base_filter_hostlist", "")
            info.setdefault("base_filter_ipset", "")
            return info

        return {
            "key": getattr(category_info, "key", category_key),
            "full_name": getattr(category_info, "full_name", category_key),
            "description": getattr(category_info, "description", ""),
            "protocol": getattr(category_info, "protocol", ""),
            "ports": getattr(category_info, "ports", ""),
            "icon_name": getattr(category_info, "icon_name", ""),
            "icon_color": getattr(category_info, "icon_color", "#909090"),
            "base_filter": getattr(category_info, "base_filter", ""),
            "base_filter_hostlist": getattr(category_info, "base_filter_hostlist", ""),
            "base_filter_ipset": getattr(category_info, "base_filter_ipset", ""),
        }

    def _load_current_strategy_id(self) -> str:
        if not self._preset_manager or not self._category_key:
            return "none"
        try:
            selections = self._preset_manager.get_strategy_selections() or {}
            return (selections.get(self._category_key) or "none").strip() or "none"
        except Exception:
            return "none"

    def _reload_category(self, *_args) -> None:
        if not self._category_key:
            return
        if self._refresh_btn:
            self._refresh_btn.set_loading(True)

        self.show_loading()
        try:
            from preset_zapret1.strategies_loader import load_v1_strategies

            self._strategies = load_v1_strategies(self._category_key) or {}
            self._current_strategy_id = self._load_current_strategy_id()
            if self._current_strategy_id and self._current_strategy_id != "none":
                self._last_enabled_strategy_id = self._current_strategy_id
            self._rebuild_tree_rows()
            self._refresh_args_preview()
            self._update_selected_label()
            self._sync_category_controls()
            self.show_success()
        except Exception as e:
            log(f"Zapret1StrategyDetailPage: cannot load strategies: {e}", "ERROR")
            self._strategies = {}
            self._rebuild_tree_rows()
            self._refresh_args_preview()
            self._update_selected_label()
            self._sync_category_controls()
            self._hide_success()
        finally:
            if self._refresh_btn:
                self._refresh_btn.set_loading(False)

    def _sorted_strategy_items(self) -> list[dict]:
        items = [s for s in (self._strategies or {}).values() if s.get("id")]

        if self._sort_mode == "alpha_asc":
            return sorted(items, key=lambda s: (s.get("name", "")).lower())
        if self._sort_mode == "alpha_desc":
            return sorted(items, key=lambda s: (s.get("name", "")).lower(), reverse=True)

        return sorted(
            items,
            key=lambda s: (
                _LABEL_ORDER.get(s.get("label"), 2),
                (s.get("name", "")).lower(),
            ),
        )

    def _rebuild_tree_rows(self) -> None:
        if not self._tree:
            return

        self._tree.clear_strategies()

        self._tree.add_strategy(
            StrategyTreeRow(
                strategy_id="none",
                name="Выключено",
                args=["Отключить обход DPI для этой категории"],
            )
        )

        if self._current_strategy_id == "custom":
            custom_lines = [ln.strip() for ln in self._get_current_args().splitlines() if ln.strip()]
            self._tree.add_strategy(
                StrategyTreeRow(
                    strategy_id="custom",
                    name="Свой набор",
                    args=custom_lines or ["Пользовательские аргументы"],
                )
            )

        for strat in self._sorted_strategy_items():
            sid = (strat.get("id") or "").strip()
            if not sid:
                continue
            args_lines = [ln.strip() for ln in (strat.get("args") or "").splitlines() if ln.strip()]
            self._tree.add_strategy(
                StrategyTreeRow(
                    strategy_id=sid,
                    name=strat.get("name", sid),
                    args=args_lines,
                )
            )

        self._apply_sort_mode()
        self._apply_search_filter()

        active_sid = self._current_strategy_id if self._tree.has_strategy(self._current_strategy_id) else "none"
        self._tree.set_selected_strategy(active_sid)

        if self._empty_label is not None:
            self._empty_label.setVisible(not bool(self._strategies))

    # ------------------------------------------------------------------
    # Header updates
    # ------------------------------------------------------------------

    def _update_header_labels(self) -> None:
        full_name = self._category_info.get("full_name", self._category_key) or self._category_key
        description = self._category_info.get("description", "")
        protocol = self._category_info.get("protocol", "")
        ports = self._category_info.get("ports", "")

        if self._title_label is not None:
            self._title_label.setText(full_name)
        if self._desc_label is not None:
            self._desc_label.setText(description)
            self._desc_label.setVisible(bool(description))

        subtitle_parts = []
        if protocol:
            subtitle_parts.append(str(protocol))
        if ports:
            subtitle_parts.append(f"порты: {ports}")

        if self._subtitle_label is not None:
            self._subtitle_label.setText(" | ".join(subtitle_parts))

        self._update_selected_label()

    def _update_selected_label(self) -> None:
        if self._selected_label is not None:
            self._selected_label.setText(f"Текущая стратегия: {self._strategy_display_name(self._current_strategy_id)}")

    # ------------------------------------------------------------------
    # Search / sort controls
    # ------------------------------------------------------------------

    def _on_search_text_changed(self, text: str) -> None:
        self._search_text = (text or "").strip().lower()
        self._apply_search_filter()

    def _on_sort_combo_changed(self, *_args) -> None:
        if not self._sort_combo:
            return
        mode = self._sort_combo.currentData()
        mode = str(mode or "recommended")
        if mode == self._sort_mode:
            return
        self._sort_mode = mode
        self._rebuild_tree_rows()

    def _apply_sort_mode(self) -> None:
        if not self._tree:
            return

        sort_map = {
            "recommended": "default",
            "alpha_asc": "name_asc",
            "alpha_desc": "name_desc",
        }
        self._tree.set_sort_mode(sort_map.get(self._sort_mode, "default"))
        self._tree.apply_sort()

    def _apply_search_filter(self) -> None:
        if self._tree:
            self._tree.apply_filter(self._search_text, set())

    def _category_supports_filter_switch(self) -> bool:
        host = str(self._category_info.get("base_filter_hostlist") or "").strip()
        ipset = str(self._category_info.get("base_filter_ipset") or "").strip()
        return bool(host and ipset)

    def _sync_category_controls(self) -> None:
        enabled = (self._current_strategy_id or "none") != "none"

        if self._enable_toggle is not None:
            self._enable_toggle.blockSignals(True)
            if hasattr(self._enable_toggle, "setChecked"):
                self._enable_toggle.setChecked(enabled)
            self._enable_toggle.blockSignals(False)

        if self._edit_args_btn is not None:
            self._edit_args_btn.setEnabled(enabled)

        if self._filter_mode_frame is not None:
            can_switch = self._category_supports_filter_switch()
            self._filter_mode_frame.setVisible(can_switch)
            if can_switch and self._filter_mode_selector is not None:
                saved_mode = self._load_category_filter_mode(self._category_key)
                self._filter_mode_selector.blockSignals(True)
                self._filter_mode_selector.setChecked(saved_mode == "ipset")
                self._filter_mode_selector.blockSignals(False)

    def _load_category_filter_mode(self, category_key: str) -> str:
        if not self._preset_manager:
            return "hostlist"
        try:
            return self._preset_manager.get_category_filter_mode(category_key)
        except Exception:
            return "hostlist"

    def _on_filter_mode_changed(self, new_mode: str) -> None:
        if not self._preset_manager or not self._category_key:
            return
        try:
            ok = self._preset_manager.update_category_filter_mode(
                self._category_key,
                new_mode,
                save_and_sync=True,
            )
            if ok is False:
                raise RuntimeError("Не удалось сохранить режим фильтрации")
            log(f"V1 filter mode set: {self._category_key} = {new_mode}", "INFO")
            if _HAS_FLUENT and InfoBar is not None:
                InfoBar.success(
                    title="Режим фильтрации",
                    content="IPset" if new_mode == "ipset" else "Hostlist",
                    parent=self.window(),
                    duration=1500,
                )
        except Exception as e:
            log(f"V1 filter mode error: {e}", "ERROR")
            if _HAS_FLUENT and InfoBar is not None:
                InfoBar.error(title="Ошибка", content=str(e), parent=self.window())
            self._sync_category_controls()

    def _default_strategy_id(self) -> str:
        for item in self._sorted_strategy_items():
            sid = str(item.get("id") or "").strip()
            if sid and sid != "none":
                return sid
        return "none"

    def _on_enable_toggled(self, enabled: bool) -> None:
        if not self._preset_manager or not self._category_key:
            return

        if enabled:
            strategy_id = (self._last_enabled_strategy_id or "").strip()
            if not strategy_id or strategy_id == "none":
                strategy_id = self._default_strategy_id()
            if strategy_id == "none":
                if self._enable_toggle is not None:
                    self._enable_toggle.blockSignals(True)
                    self._enable_toggle.setChecked(False)
                    self._enable_toggle.blockSignals(False)
                self._sync_category_controls()
                return
            self._on_strategy_selected(strategy_id)
            return

        if self._current_strategy_id and self._current_strategy_id != "none":
            self._last_enabled_strategy_id = self._current_strategy_id
        self._on_strategy_selected("none")

    # ------------------------------------------------------------------
    # Strategy selection
    # ------------------------------------------------------------------

    def _on_strategy_selected(self, strategy_id: str) -> None:
        if not self._preset_manager or not self._category_key:
            return

        sid = (strategy_id or "none").strip() or "none"
        self.show_loading()
        try:
            ok = self._preset_manager.set_strategy_selection(
                self._category_key,
                sid,
                save_and_sync=True,
            )
            if ok is False:
                raise RuntimeError("Не удалось сохранить выбор стратегии")

            self._current_strategy_id = sid
            if sid != "none":
                self._last_enabled_strategy_id = sid
            self._update_selected_label()
            self._refresh_args_preview()
            self._sync_category_controls()

            if self._tree and self._tree.has_strategy(sid):
                self._tree.set_selected_strategy(sid)

            self.strategy_selected.emit(self._category_key, sid)
            log(f"V1 strategy set: {self._category_key} = {sid}", "INFO")

            if _HAS_FLUENT and InfoBar is not None:
                InfoBar.success(
                    title="Стратегия применена",
                    content=self._strategy_display_name(sid),
                    parent=self.window(),
                    duration=1800,
                )

            self.show_success()

        except Exception as e:
            log(f"V1 strategy selection error: {e}", "ERROR")
            if _HAS_FLUENT and InfoBar is not None:
                InfoBar.error(title="Ошибка", content=str(e), parent=self.window())
            self._reload_category()

    def _strategy_display_name(self, strategy_id: str) -> str:
        sid = (strategy_id or "").strip()
        if not sid or sid == "none":
            return "Выключено"
        if sid == "custom":
            return "Свой набор"
        info = (self._strategies or {}).get(sid)
        if info:
            return info.get("name", sid)
        return sid

    # ------------------------------------------------------------------
    # Args preview / editor
    # ------------------------------------------------------------------

    def _refresh_args_preview(self) -> None:
        if self._args_preview_label is None:
            return

        current_args = self._get_current_args()
        if not current_args:
            self._args_preview_label.setText("(нет аргументов)")
            return

        lines = [ln for ln in current_args.splitlines() if ln.strip()]
        preview = "\n".join(lines[:8])
        if len(lines) > 8:
            preview += f"\n... (+{len(lines) - 8} строк)"
        self._args_preview_label.setText(preview)

    def _get_current_args(self) -> str:
        if not self._preset_manager or not self._category_key:
            return ""
        try:
            preset = self._preset_manager.get_active_preset()
            if not preset:
                return ""
            cat = (preset.categories or {}).get(self._category_key)
            if not cat:
                return ""
            return (cat.tcp_args or cat.udp_args or "").strip()
        except Exception:
            return ""

    def _open_args_editor(self, *_args) -> None:
        if not _HAS_FLUENT or (self._current_strategy_id or "none") == "none":
            return
        try:
            dlg = _ArgsEditorDialog(self._get_current_args(), self.window())
            if dlg.exec():
                self._save_custom_args(dlg.get_text().strip())
        except Exception as e:
            log(f"Zapret1StrategyDetailPage: args editor error: {e}", "ERROR")

    def _save_custom_args(self, args_text: str) -> None:
        if not self._preset_manager or not self._category_key:
            return

        try:
            from preset_zapret1.preset_model import CategoryConfigV1

            preset = self._preset_manager.get_active_preset()
            if not preset:
                return

            if self._category_key not in preset.categories:
                preset.categories[self._category_key] = CategoryConfigV1(name=self._category_key)

            cat = preset.categories[self._category_key]

            protocol = (self._category_info.get("protocol") or "").upper()
            is_udp = any(token in protocol for token in ("UDP", "QUIC", "L7", "RAW"))

            if is_udp:
                cat.udp_args = args_text
                cat.tcp_args = ""
            else:
                cat.tcp_args = args_text
                cat.udp_args = ""

            cat.strategy_id = "custom" if args_text else "none"
            preset.touch()

            if hasattr(self._preset_manager, "_save_and_sync_category"):
                self._preset_manager._save_and_sync_category(preset, self._category_key)
            else:
                self._preset_manager._save_and_sync_preset(preset)

            self._current_strategy_id = cat.strategy_id
            if self._current_strategy_id != "none":
                self._last_enabled_strategy_id = self._current_strategy_id
            self.strategy_selected.emit(self._category_key, self._current_strategy_id)
            self._sync_category_controls()

            if _HAS_FLUENT and InfoBar is not None:
                if args_text:
                    InfoBar.success(
                        title="Аргументы сохранены",
                        content="Пользовательские аргументы применены",
                        parent=self.window(),
                        duration=1800,
                    )
                else:
                    InfoBar.success(
                        title="Аргументы очищены",
                        content="Категория возвращена в режим 'Выключено'",
                        parent=self.window(),
                        duration=1800,
                    )

            self._reload_category()

        except Exception as e:
            log(f"V1 save custom args error: {e}", "ERROR")
            if _HAS_FLUENT and InfoBar is not None:
                InfoBar.error(title="Ошибка", content=str(e), parent=self.window())

    # ------------------------------------------------------------------
    # Feedback indicators
    # ------------------------------------------------------------------

    def show_loading(self) -> None:
        if self._spinner is not None:
            try:
                if hasattr(self._spinner, "start"):
                    self._spinner.start()
            except Exception:
                pass
            self._spinner.show()

        if self._success_icon is not None:
            self._success_icon.hide()

    def show_success(self) -> None:
        if self._spinner is not None:
            try:
                if hasattr(self._spinner, "stop"):
                    self._spinner.stop()
            except Exception:
                pass
            self._spinner.hide()

        if self._success_icon is not None:
            if _HAS_QTA and qta is not None:
                try:
                    self._success_icon.setPixmap(qta.icon("fa5s.check-circle", color="#6ccb5f").pixmap(16, 16))
                except Exception:
                    pass
            self._success_icon.show()

        self._success_timer.start(1200)

    def _hide_success(self) -> None:
        if self._success_icon is not None:
            self._success_icon.hide()
